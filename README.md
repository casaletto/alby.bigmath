# alby.bigmath

a c++ wrapper around mpfr and gmp to make extreme maths more pleasant.

move seamlessly between exact rational number arithmetic (gmp)\
and almost unlimited precision floating point aritmetic (mpfr).



# base projects

* http://www.mpfr.org
* https://gmplib.org



# packages required

* gcc + standard linux toolchain
* libgmp-dev
* libgmp10
* libmpfr-dev
* libmpfr4



# how do I build it?

```
$ make 
```



# how do you use it in your project?

*.cpp

```
#include ".../lib/stringhlp.h"
#include ".../lib/stringcat.h"
#include ".../lib/mpfr_t_wrapper.h"
#include ".../lib/mpfr.h"
```

in your makefile

```
$ g++ -c *.cpp
$ g++ -s -o exefile *.o -static -static-libgcc -static-libstdc++ -l:libmpfr.a -l:libgmp.a -llibalbybigmath.a
```

I hate dll hell. I do static linking as much as possible.



# developed and tested on

```
$ gcc --version
gcc (Ubuntu 6.3.0-12ubuntu2) 6.3.0 20170406
```

```
$ uname -a
Linux xxxxxxx 4.10.0-28-generic #32-Ubuntu SMP Fri Jun 30 05:32:18 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
```

I had a bad dream that I partly developed and tested this on windoze 10 mingw64/msys64, but yeh, probably just a dream.



# here's an example

1.2e+10 + 3.4 + 5.6e-10\
and\
1.2e+1000 + 3.4 + 5.6e-1000

```

#include ".../lib/stringhlp.h"
#include ".../lib/stringcat.h"
#include ".../lib/mpfr_t_wrapper.h"
#include ".../lib/mpfr.h"

namespace abm = alby::bigmath ; 

void example1()
{
	abm::mpfr::setPrecision( 22 ) ;

	auto a = abm::mpfr( "1.2e10" ) ;
	auto b = abm::mpfr( "3.4" ) ;
	auto c = abm::mpfr( "5.6e-10" ) ;	

	auto sum = a + b + c ;

	std::cout 
		<< a << " + " 
		<< b << " + " 
		<< c 
		<< std::endl 
		<< std::endl 
		<< "= " 
		<< sum 
		<< std::endl 
		<< std::endl 
		<< "= " 
		<< sum.toScientificNotation()
		<< std::endl 
		<< std::endl ;

	abm::mpfr::setPrecision( 2002 ) ;

	a = abm::mpfr( "1.2e1000" ) ;
	b = abm::mpfr( "3.4" ) ;
	c = abm::mpfr( "5.6e-1000" ) ;	

	sum = a + b + c ;

	std::cout 
		<< a.toScientificNotation() << " + " 
		<< b << " + " 
		<< c.toScientificNotation() 
		<< std::endl 
		<< std::endl 
		<< "= " 
		<< sum 
		<< std::endl 
		<< std::endl  
		<< "= " 
		<< sum.toScientificNotation()  
		<< std::endl ;
}

```

output

```

+12000000000.0 + +3.4 + +0.00000000056

= +12000000003.40000000056

= +1.200000000340000000056E+10

```

and 

```

+1.2E+1000 + +3.4 + +5.6E-1000

= +12000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003.40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000056

= +1.200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000340000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000056E+1000

```



# here's another example, calculate π to 1XXXXX decimal places 


TO DO

```
Nilakantha’s accelerated series for π

	π = 3 + 4/(2*3*4) - 4/(4*5*6) + 4/(6*7*8) - 4/(8*9*10) + 4/(10*11*12) - 4/(12*13*14) ...
```

```
the class two 1989 Ramanujan–Sato series, 25 digits per term

	1 / 12π = sum( n = 0, n = ∞ ) ( num / den )

where 

	num = pow( -1, n ) * (6n)! * ( A + nB )
	den = pow( n!, 3 ) * (3n)! * pow( C, n + 0.5 )

	A = 212 175 710 912 sqrt(61) + 1 657 145 277 365,
	B = 13 773 980 892 672 sqrt(61) + 107 578 229 802 750,
	C = ( 5280 ( 236 674 + 30 303 sqrt(61) ) )  pow 3.
```



# how do I run the unit tests?

```
$ make test
```



# useful links

* http://www.mpfr.org
* https://gmplib.org
* https://regexr.com/3m16c
* https://en.wikipedia.org/wiki/Borwein%27s_algorithm
* https://helloacm.com/two-simple-equations-to-compute-pi/


