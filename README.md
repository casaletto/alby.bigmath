# alby.bigmath


a c++ wrapper around mpfr and gmp to make extreme maths more pleasant.

move seamlessly between exact rational number arithmetic (gmp)\
and almost unlimited precision floating point aritmetic (mpfr).


# base projects


* http://www.mpfr.org
* https://gmplib.org


# packages required


* gcc + standard linux toolchain
* libgmp-dev
* libgmp10
* libmpfr-dev
* libmpfr4


# how do I build it?


```
$ make 
```


# how do you use it in your project?


*.cpp

```
#include <gmp.h>
#include <mpfr.h>

#include "../lib/numberBase.h"
#include "../lib/stringhlp.h"
#include "../lib/stringcat.h"
#include "../lib/numberhlp.h"
#include "../lib/mpfr_t_wrapper.h"
#include "../lib/mpfr.h"
#include "../lib/random.h"
```

in your makefile

```
$ g++ -c *.cpp
$ g++ -s -o exefile *.o -static -static-libgcc -static-libstdc++ -l:libmpfr.a -l:libgmp.a -llibalbybigmath.a
```

I hate dll hell. I do static linking as much as possible.


# developed and tested on


```
$ gcc --version
gcc (Ubuntu 6.3.0-12ubuntu2) 6.3.0 20170406
```

```
$ uname -a
Linux xxxxxxx 4.10.0-28-generic #32-Ubuntu SMP Fri Jun 30 05:32:18 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
```

I had a bad dream that I partly developed and tested this on windoze 10 mingw64/msys64, but yeh, probably just a dream.


# here's an example


1.2e+10 + 3.4 + 5.6e-10\
and\
1.2e+1000 + 3.4 + 5.6e-1000

```
namespace abm = alby::bigmath ; 

void example1()
{
	abm::mpfr::setSignificantFigures( 22 ) ;

	auto a = abm::mpfr( "1.2e10" ) ;
	auto b = abm::mpfr( "3.4" ) ;
	auto c = abm::mpfr( "5.6e-10" ) ;	

	auto sum = a + b + c ;

	std::cout 
		<< a << " + " 
		<< b << " + " 
		<< c 
		<< std::endl 
		<< std::endl 
		<< "= " 
		<< sum 
		<< std::endl 
		<< std::endl 
		<< "= " 
		<< sum.toScientificNotation()
		<< std::endl 
		<< std::endl ;

	abm::mpfr::setSignificantFigures( 2002 ) ;

	a = abm::mpfr( "1.2e1000" ) ;
	b = abm::mpfr( "3.4" ) ;
	c = abm::mpfr( "5.6e-1000" ) ;	

	sum = a + b + c ;

	std::cout 
		<< a.toScientificNotation() << " + " 
		<< b << " + " 
		<< c.toScientificNotation() 
		<< std::endl 
		<< std::endl 
		<< "= " 
		<< sum 
		<< std::endl 
		<< std::endl  
		<< "= " 
		<< sum.toScientificNotation()  
		<< std::endl ;
}

```

output

```

+12000000000.0 + +3.4 + +0.00000000056

= +12000000003.40000000056

= +1.200000000340000000056E+10

```

and 

```

+1.2E+1000 + +3.4 + +5.6E-1000

= +12000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003.40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000056

= +1.200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000340000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000056E+1000

```


# calculate π, method #1


![alt text](https://github.com/casaletto/alby.bigmath/blob/master/doc/pi%20nilakantha.png "pi #1")


500 000 iterations yield 17 dp\
+3.14159265358979323...\
\
5 000 000 iterations yield 20 dp\
+3.14159265358979323846...


```
void pi_nilakantha()
{
	abm::mpfr::setSignificantFigures( 1000 ) ;
	abm::mpfr::setDebug( false ) ;

	abm::mpfr pi ;

	auto plus = true ;

	for ( unsigned long i = 2 ; i <= 5000 * 2 ; i += 2 )
	{
		auto term = pi_nilakantha_term(i) ; 

		pi = plus ? pi + term : pi - term ;

		plus = ! plus ;	 
	}

	pi += 3 ; 

	std::cout << pi << std::endl ;
}

abm::mpfr pi_nilakantha_term( unsigned long _i )
{
	static abm::mpfr _4 = 4 ;

	abm::mpfr i = _i ;

	return _4 / ( i * (i+1) * (i+2) ) ;
}
```


# calculate π, method #2


![alt text](https://github.com/casaletto/alby.bigmath/blob/master/doc/pi%20ramujan.png "pi #2")


```
void pi_ramanujan()
{
}
```


# calculate π, method #3






# how do I run the unit tests?


```
$ make test
```


# useful links


* http://www.mpfr.org
* https://gmplib.org
* https://regexr.com/3m16c
* https://en.wikipedia.org/wiki/Borwein%27s_algorithm
* https://helloacm.com/two-simple-equations-to-compute-pi
* http://www.pi314.net/eng/borwein.php
* https://ipfs.io/ipfs/QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco/wiki/Borwein%27s_algorithm.html
* https://www.carma.newcastle.edu.au/jon/RAMA125f.pdf
* https://crypto.stanford.edu/pbc/notes/pi/ramanujan.html


