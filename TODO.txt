---------------------------------------------------------------------
backlog
---------------------------------------------------------------------

//ALBY------- ++++ FIX THIS all operators like operator+



// fix misc tostring functions
mprf::toDecimalPlaces( x ) ;                  // 1.29456e23  1dp -->  1.3E23,    0 dp ==> 1.0E23
mprf::toSignificantFigures( x ) ;             // 2sf => 1.3e23

// fix 	operator+( const mpfr& op1, const mpfr& op2 )  

// maths operations should throw an exextion if the number cant be represebted

// round to n dp


. Round function to x dp
... Convert to rational, fix numerator, convert back to mpfr ?????
// rounding to x dp 0.5 goes up

// unit test the generate random numbers and test them  mpfr comapared to float

-----------------------------------------------------------------------

new functions 


-----------------------------------------------------------------------

// function to convert to rational numertaor / denominator, reduced to lcm/gcf

-----------------------------------------------------------------------


// when i add / mult / whatever numbers,  what precision do i use ?
// test that precision comes from the lhs, maybe ???

// eg, we cant have the situation where adding the same two numbers in different ways produces differnet results:


----------------------------------------------------------------------
// should be able to add / multiply two numbers in ether direction and get same result

// fix this test
ERROR:
a14               -12.345678900000000000000000000000000000000000 [prec 44(10) 180(2)]
a15               -12.345                                        [prec 5(10) 50(2)]

a16 = a14 + a15 = -24.691357799999995792313711717724800109863281 [prec 44(10) 180(2)]
a17 = a15 + a14 = -24.691                                        [prec 5(10) 50(2)]


-----------------------------------------------------------------------

// < > == >= <=
. Comparison functions need string comparision
// 1a. normalist the numbers (this should be standard stuff) as two strings
// 1a. strcmp  +a.aaaa == +aaaaa.aa
// 1b. strcmp  -a.aaaa == -aaaaa.aa
// equal, !=, are easy 
// check sign first
// 0.00001  vs 0.000002
// 31.001  vs 3.1
//             3.14 vs 3.140001  (6 dp to the right)
//-> becomes   3140000.     vs   3140001.           
// convert the number to numerator denom with same pow10 base , can just shift decimal point, then compare as gmp integers.


-----------------------------------------------------------------------

// demo 1e1000 + 1e-1000 + 1

-----------------------------------------------------------------------

// create function to random [0.0, 1)

// mpfr_urandomb ( seed ??? )

-----------------------------------------------------------------------

 

 Get rid of gmp cxx, make my own c++ class
. Repeat pattern for gmp
. Conversion between mrfp and gmp


-----------------------------------------------------------------------

* pi calculation example in readme - 2 examples

https://en.wikipedia.org/wiki/Borwein%27s_algorithm


Class number 2 (1989) Ramanujanâ€“Sato series for l/ pi
25 digits per term

where
A = 212 175 710 912 sqrt(61) + 1 657 145 277 365,
B = 13 773 980 892 672 sqrt(61) + 107 578 229 802 750,
C = [ 5280 (236 674 + 30 303 sqrt(61) ) ]  pow 3.

vs compare to refernce pi


-----------------------------------------------------------------------

* unit tests - which framework ???
* do proper tests - do asserts for unit tests - for each section
void print_number(int* myInt) {
  assert (myInt!=NULL);
  printf ("%d\n",*myInt);
}

* put thest code in /test folder


---------------------------------------------------------------------
done
---------------------------------------------------------------------

// global precision
// global rounding
// test a base 16 number
// test a base 2 number
// * how to ignore *.o in vscode

*how to run make in vscode

//ALBY delete me
//operator mpq_class() ;
//mpq_class toMpq() ;

// ceil
// floor
// trunc

// overload += *= /= -+ ^=

// operators and constructors from strings
// x = a + "3.14" 
// x = "3.14" + a

// handle mpfr( "1E10" ) if base 10

// change name precison to sifnificantFigures ??? no, changed name to local and global

// cahnge to 
static const mpfr_prec_t precisionDefault = (mpfr_prec_t) 100 
// to
static const unsigned long precision10default = 100 ;




// change precision  to # of significant decimal digits
. Add 10 or more bin digits to sig decimal digits for extra x decimal places

binary precision = log2( power( 10, decimal sigdigs)) + 20

* factorial
* sqrt

// change file nam stringhlper to stringhlp
// change sprintf to cat

* put in lib

// fix random() to stringcat

// handle -0.0, convert to +0.0

// print to n significant digits

// round to n significant digits

// refactor numberhlp

//ALBY change to vector  tostring

// toStirng debug issue ????

// fix constructir stuff


// tostring()
. Tostring to default to  removing trailing zeros
. round last sig fig
. chenge -0.0 to +0.0
. handle "-0.00000123456789" to 5 dp


		// make function call const
		//auto str = const_cast<mpfr*>( &mpfr1 )->toString() ;
				
		//os << str ;

