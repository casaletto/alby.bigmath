---------------------------------------------------------------------
backlog
---------------------------------------------------------------------

// change precision  to # of significant decimal digits
. Add 10 or more bin digits to sig decimal digits for extra x decimal places

binary precision = log2( power( 10, decimal sigdigs)) + 20

* factorial
* sqrt





// tostring()
. Tostring to default to  removing trailing zeros
.normalise())

// demo 1e1000 + 1e-1000 + 1

// < > == >= <=
. Comparison functions need string comparision


// mpfr_urandomb ( seed ??? )

// test that precision coims from the lhs
 




. Round function to x dp
... Convert to rational, fix numerator, convert back to mpfr
// rounding to x dp 0.5 goes up

.
* do proper tests - do asserts for unit tests - for each section
void print_number(int* myInt) {
  assert (myInt!=NULL);
  printf ("%d\n",*myInt);
}


 Get rid of gmp cxx, make my own c++ class
. Repeat pattern for gmp
. Conversion between mrfp and gmp

* pi calculation example in readme - 2 examples

https://en.wikipedia.org/wiki/Borwein%27s_algorithm



Class number three Ramanujan type series for l/ pi
25 digits per term

where
A = 212 175 710 912 sqrt(61) + 1 657 145 277 365,
B = 13 773 980 892 672 sqrt(61) + 107 578 229 802 750,
C = [ 5280 (236 674 + 30 303 sqrt(61) ) ]  pow 3.

vs compare to
http://www.piday.org/million/


* put in lib

---------------------------------------------------------------------
done
---------------------------------------------------------------------

// global precision
// global rounding
// test a base 16 number
// test a base 2 number
// * how to ignore *.o in vscode

*how to run make in vscode

//ALBY delete me
//operator mpq_class() ;
//mpq_class toMpq() ;

// ceil
// floor
// trunc

// overload += *= /= -+ ^=

// operators and constructors from strings
// x = a + "3.14" 
// x = "3.14" + a

// handle mpfr( "1E10" ) if base 10

// change name precison to sifnificantFigures ??? no, changed name to local and global

