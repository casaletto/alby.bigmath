---------------------------------------------------------------------
backlog
---------------------------------------------------------------------

// function to convert to rational numertaor / denominator, reduced to lcm/gcf

void toFraction     (                       std::string numerator, std::string& denominator, bool reduce = true ) ;			

-314 / -100 
-157 / -50

Function: void mpz_gcd (mpz_t rop, const mpz_t op1, const mpz_t op2)

    Set rop to the greatest common divisor of op1 and op2. 


mpz_t integ;
  mpz_init (integ);
  …
  mpz_add (integ, …);
  …
  mpz_sub (integ, …);

  /* Unless the program is about to exit, do ... */
  mpz_clear (integ);

-------------------------------------------------



1.

------- ++++ FIX THIS all operators like operator+

// sf IS THE MAX sf OF THE OPERANDS INVOLVED

// fix 	operator+( const mpfr& op1, const mpfr& op2 )  et al 

// when i add / mult / whatever numbers,  what sf do i use ?
// test that sf comes from the lhs, maybe ???

// eg, we cant have the situation where adding the same two numbers in different ways produces differnet results:


// should be able to add / multiply two numbers in ether direction and get same result

// fix this test
ERROR:
a14               -12.345678900000000000000000000000000000000000 [sf 44(10) 180(2)]
a15               -12.345                                        [sf 5(10) 50(2)]

a16 = a14 + a15 = -24.691357799999995792313711717724800109863281 [sf 44(10) 180(2)]
a17 = a15 + a14 = -24.691                                        [sf 5(10) 50(2)]


----------------------------------------------------------------------

-----------------------------------------------------------------------
3.


-----------------------------------------------------------------------
4. 

gmp raw toRational() ; / return gmp rational

... Convert to rational, fix numerator, convert back to mpfr ?????

later, return class

-----------------------------------------------------------------------
5.

// < > == >= <=  !=



---> conclusion: comapare as gmp rational <<-----

. Comparison functions need string comparision
// 1a. normalist the numbers (this should be standard stuff) as two strings
// 1a. strcmp  +a.aaaa == +aaaaa.aa
// 1b. strcmp  -a.aaaa == -aaaaa.aa
// equal, !=, are easy 
// check sign first
// 0.00001  vs 0.000002
// 31.001  vs 3.1
//             3.14 vs 3.140001  (6 dp to the right)
//-> becomes   3140000.     vs   3140001.           
// convert the number to numerator denom with same pow10 base , can just shift decimal point, then compare as gmp rationals. ????


-----------------------------------------------------------------------
6.

// fix 	mpfr::randomBytes( int bytes ) // hex string of random bytes

// create function to random [0.0, 1)
// mpfr_urandomb ( seed ??? )




-----------------------------------------------------------------------
7.

// unit test the generate random numbers and test them  mpfr comapared to float
????????????????

power
2147483647 (2^31-1) 

double can do 15 or 16sf,

eg
while true

	rnd1 = random 5dp
	rnd2 = random 5dp 

	numMe = rnd1 * 2147483647    large integer

	num c++ = ditto (double)

	// compare to 12 dp

-----------------------------------------------------------------------
8. first pi example - nama***



https://en.wikipedia.org/wiki/Borwein%27s_algorithm


-----------------------------------------------------------------------
9. second pi example

Class number 2 (1989) Ramanujan–Sato series for l/ pi
25 digits per term

where
A = 212 175 710 912 sqrt(61) + 1 657 145 277 365,
B = 13 773 980 892 672 sqrt(61) + 107 578 229 802 750,
C = [ 5280 (236 674 + 30 303 sqrt(61) ) ]  pow 3.

vs compare to refernce pi


-----------------------------------------------------------------------
10.

* unit tests - which framework ???
* do proper tests - do asserts for unit tests - for each section
void print_number(int* myInt) {
  assert (myInt!=NULL);
  printf ("%d\n",*myInt);
}

* put thest code in /test folder

-----------------------------------------------------------------------
11.


 make my own c++ class for gmp
. Repeat pattern for gmp
. Conversion between mrfp and gmp



###########################################################################################


done
---------------------------------------------------------------------
sf
// global sf
// global rounding
// test a base 16 number
// test a base 2 number
// * how to ignore *.o in vscode

*how to run make in vscode

 delete me
//operator mpq_class() ;
//mpq_class toMpq() ;

// ceil
// floor
// trunc

// overload += *= /= -+ ^=

// operators and constructors from strings
// x = a + "3.14" 
// x = "3.14" + a

// handle mpfr( "1E10" ) if base 10

// change name sf to sifnificantFigures ??? no, changed name to local and global


---------------------------------------------------------------



---------------------------------------------------

// change sf  to # of significant decimal digits
. Add 10 or more bin digits to sig decimal digits for extra x decimal places

binary sf = log2( power( 10, decimal sigdigs)) + 20

* factorial
* sqrt

// change file nam stringhlper to stringhlp
// change sprintf to cat

* put in lib

// fix random() to stringcat

// handle -0.0, convert to +0.0

// print to n significant digits

// round to n significant digits

// refactor numberhlp

change to vector  tostring

// toStirng debug issue ????

// fix constructir stuff


// tostring()
. Tostring to default to  removing trailing zeros
. round last sig fig
. chenge -0.0 to +0.0
. handle "-0.00000123456789" to 5 dp


		// make function call const
		//auto str = const_cast<mpfr*>( &mpfr1 )->toString() ;
				
		//os << str ;

// cahnge to 
static const mpfr_sf_t psfDefault = (mpfr_sf_t) 100 
// to
static const unsigned long sfn10default = 100 ;

// maths operations should throw an exextion if the number cant be represebted

// demo 1e1000 + 1e-1000 + 1

Get rid of gmp cxx

-------------

BUG 

need to implement mpfr:roundSignificantFigures 
fix in 

	mpfr::mpfr( const mpfr& rhs, unsigned long theisf10 ) // constr



	abm::mpfr c( "2.0234", 10, 20 ) ;
	abm::mpfr d( "3.1234", 10, 30 ) ;

	std::cout << "c      = " << c << std::endl ;
	std::cout << "d      = " << d << std::endl ;
	std::cout << "c + d  = " << (c + d) << std::endl ;
	std::cout << "d + c  = " << (d + c) << std::endl ;

	d += c  ; 
	c += d  ; 
	std::cout << "c = " << c << std::endl ;
	std::cout << "d = " << d << std::endl ;

	abm::mpfr e( c, 3UL ) ;
	abm::mpfr f( d, 3UL ) ;
	std::cout << "e = " << e << std::endl ;
	std::cout << "f = " << f << std::endl ;

	abm::mpfr g( c, 2UL ) ;
	abm::mpfr h( d, 2UL ) ;
	std::cout << "g = " << g << std::endl ;
	std::cout << "h = " << h << std::endl ;

c      = +2.0234000000000000000 [sf 20(10), 100(2), len 22 ]
d      = +3.12340000000000000000000000000 [sf 30(10), 133(2), len 32 ]
c + d  = +5.14680000000000000000000000000 [sf 30(10), 133(2), len 32 ]
d + c  = +5.14680000000000000000000000000 [sf 30(10), 133(2), len 32 ]
c = +7.17020000000000000000000000000 [sf 30(10), 133(2), len 32 ]
d = +5.14680000000000000000000000000 [sf 30(10), 133(2), len 32 ]
e = +7.17 [sf 3(10), 43(2), len 5 ]
f = +5.15 [sf 3(10), 43(2), len 5 ]
g = +7.2 [sf 2(10), 40(2), len 4 ]
h = +5.2 [sf 2(10), 40(2), len 4 ]           <==== BUG !!!!


get rid of baseX constructir - convert to enum

change "sf" to "significantFigures"



std::string
	mpfr::roundToDecimalPlaces( long theDecimalPlaces ) // return number rounded to x dp

std::string
	mpfr::roundToSignificantDigits( ulong sf ) // return number rounded to x sf





mpfr roundDecimalPlaces     ( unsigned long dp ) ; 
mpfr roundSignificantFigures( unsigned long sf ) ;

NOT DOING void toMixedFraction(  ... ) 
-3 +14/+100
-3 7/+50


################################################################################################

