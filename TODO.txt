---------------------------------------------------------------------
backlog
---------------------------------------------------------------------


//ALBY need to have a new method of determining precision
// BUG:  precision - THIS IS A BIG ONE 


// when i add two numbers, i have to determine each one to its each precision
// then conversion the less precision one to the higher precision
// then add the two numbers
// same for other math operations

// eg, we cant have the situation where adding the same two numbers in different ways produces differnet results:

ERROR:
a14               -12.345678900000000000000000000000000000000000 [prec 44(10) 180(2)]
a15               -12.345                                        [prec 5(10) 50(2)]

a16 = a14 + a15 = -24.691357799999995792313711717724800109863281 [prec 44(10) 180(2)]
a17 = a15 + a14 = -24.691                                        [prec 5(10) 50(2)]

CORRECT:

	std:string normalise( const std:string& str, unsigned long sigfig )



// tostring()
. Tostring to default to  removing trailing zeros
. round last sig fig
. chenge -0.0 to +0.0
. handle "-0.00000123456789" to 5 dp

// handle -0.0, convert to +0.0

-----------------------------------------------------------------------

// demo 1e1000 + 1e-1000 + 1

// < > == >= <=
. Comparison functions need string comparision
// 1a. normalist the numbers (this should be standard stuff) as two strings
// 1a. strcmp  +a.aaaa == +aaaaa.aa
// 1b. strcmp  -a.aaaa == -aaaaa.aa
// equal, !=, are easy 
// check sign first
// 0.00001  vs 0.000002
// 31.001  vs 3.1
//             3.14 vs 3.140001  (6 dp to the right)
//-> becomes   3140000.     vs   3140001.           
// convert the number to numerator denom with same pow10 base , can just shift decimal point, then compare as gmp integers.

// mpfr_urandomb ( seed ??? )

// test that precision comes from the lhs
 




. Round function to x dp
... Convert to rational, fix numerator, convert back to mpfr ?????
// rounding to x dp 0.5 goes up

.


 Get rid of gmp cxx, make my own c++ class
. Repeat pattern for gmp
. Conversion between mrfp and gmp

* pi calculation example in readme - 2 examples

https://en.wikipedia.org/wiki/Borwein%27s_algorithm



Class number three Ramanujan type series for l/ pi
25 digits per term

where
A = 212 175 710 912 sqrt(61) + 1 657 145 277 365,
B = 13 773 980 892 672 sqrt(61) + 107 578 229 802 750,
C = [ 5280 (236 674 + 30 303 sqrt(61) ) ]  pow 3.

vs compare to
http://www.piday.org/million/



* unit tests - which framework ???
* do proper tests - do asserts for unit tests - for each section
void print_number(int* myInt) {
  assert (myInt!=NULL);
  printf ("%d\n",*myInt);
}

* put thest code in /test folder





---------------------------------------------------------------------
done
---------------------------------------------------------------------

// global precision
// global rounding
// test a base 16 number
// test a base 2 number
// * how to ignore *.o in vscode

*how to run make in vscode

//ALBY delete me
//operator mpq_class() ;
//mpq_class toMpq() ;

// ceil
// floor
// trunc

// overload += *= /= -+ ^=

// operators and constructors from strings
// x = a + "3.14" 
// x = "3.14" + a

// handle mpfr( "1E10" ) if base 10

// change name precison to sifnificantFigures ??? no, changed name to local and global

// cahnge to 
static const mpfr_prec_t precisionDefault = (mpfr_prec_t) 100 
// to
static const unsigned long precision10default = 100 ;




// change precision  to # of significant decimal digits
. Add 10 or more bin digits to sig decimal digits for extra x decimal places

binary precision = log2( power( 10, decimal sigdigs)) + 20

* factorial
* sqrt

// change file nam stringhlper to stringhlp
// change sprintf to cat

* put in lib

// fix random() to stringcat

